<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decent Duck's Chess</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #E0F7FA; /* Light sky blue */
            touch-action: manipulation;
        }
        h1 {
            font-family: 'Fredoka One', cursive;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 700px;
            max-height: 700px;
            border: 5px solid #5C8D89; /* Dark pond border */
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15), 0 6px 6px rgba(0,0,0,0.1);
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .square img {
            width: 85%;
            height: 85%;
            object-fit: contain;
            z-index: 10;
            cursor: pointer;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }
        .light {
            background-color: #A7D7C5; /* Lily pad green */
        }
        .dark {
            background-color: #74B49B; /* Pond water green */
        }
        .selected {
            background-color: #F9E79F !important; /* Sandy shore yellow */
        }
        .valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40%;
            height: 40%;
            background-color: rgba(43, 156, 190, 0.6); /* Water ripple blue */
            border-radius: 50%;
            z-index: 5;
        }
        .check {
             background-color: #f7a29f !important; /* reddish warning */
        }
        .promotion-modal {
            background-color: rgba(0, 0, 0, 0.6);
        }
        .promotion-choice {
            transition: transform 0.2s;
        }
        .promotion-choice:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-blue-50 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="text-center mb-4">
        <h1 class="text-4xl md:text-6xl text-cyan-800">ðŸ¦† Decent Duck's Chess ðŸ¦†</h1>
        <p id="status" class="text-lg md:text-xl text-cyan-700 mt-2 font-semibold">White's Turn</p>
    </div>

    <div id="board" class="board"></div>

    <button id="resetButton" class="mt-4 px-6 py-3 bg-amber-400 text-amber-900 font-bold rounded-lg shadow-lg hover:bg-amber-500 focus:outline-none focus:ring-2 focus:ring-amber-600 focus:ring-opacity-50 transition-transform transform hover:scale-105">
        New Game
    </button>
    
    <!-- Pawn Promotion Modal -->
    <div id="promotionModal" class="promotion-modal fixed inset-0 w-full h-full items-center justify-center hidden z-50">
        <div class="bg-white p-6 rounded-lg shadow-2xl text-center">
            <h3 class="text-2xl font-bold mb-4 text-gray-800">Promote your Pawn!</h3>
            <div id="promotionChoices" class="flex justify-center space-x-4">
                <!-- Choices will be inserted here by JS -->
            </div>
        </div>
    </div>


    <script>
    // --- DOM Elements ---
    const boardElement = document.getElementById('board');
    const statusElement = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');
    const promotionModal = document.getElementById('promotionModal');
    const promotionChoices = document.getElementById('promotionChoices');

    // --- Game State ---
    let board = [];
    let currentPlayer = 'white';
    let selectedPiece = null;
    let whiteKingPosition = [7, 4];
    let blackKingPosition = [0, 4];
    let gameEnded = false;
    let promotionResolver = null;

    // --- Piece Definitions ---
    // Using custom images for a more thematic look
    const pieces = {
        'white_pawn': { value: 1, img: '<img src="https://i.imgur.com/WqEeGcV.png" alt="White Pawn">' },
        'white_rook': { value: 5, img: '<img src="https://i.imgur.com/VaOAiw0.png" alt="White Rook">' },
        'white_knight': { value: 3, img: '<img src="https://i.imgur.com/aQPSdGo.png" alt="White Knight">' },
        'white_bishop': { value: 3, img: '<img src="https://i.imgur.com/HoxXFCB.png" alt="White Bishop">' },
        'white_queen': { value: 9, img: '<img src="https://i.imgur.com/ORYOBNe.png" alt="White Queen">' },
        'white_king': { value: 100, img: '<img src="https://i.imgur.com/safa3Uv.png" alt="White King">' },
        'black_pawn': { value: 1, img: '<img src="https://i.imgur.com/G8HI6jV.png" alt="Black Pawn">' },
        'black_rook': { value: 5, img: '<img src="https://i.imgur.com/xG4MoCY.png" alt="Black Rook">' },
        'black_knight': { value: 3, img: '<img src="https://i.imgur.com/MVXiC6J.png" alt="Black Knight">' },
        'black_bishop': { value: 3, img: '<img src="https://i.imgur.com/Kg8Z0Vv.png" alt="Black Bishop">' },
        'black_queen': { value: 9, img: '<img src="https://i.imgur.com/atQD6jW.png" alt="Black Queen">' },
        'black_king': { value: 100, img: '<img src="https://i.imgur.com/h9NbkDA.png" alt="Black King">' },
    };

    // --- Game Initialization ---
    function createBoard() {
        const initialBoard = [
            ['black_rook', 'black_knight', 'black_bishop', 'black_queen', 'black_king', 'black_bishop', 'black_knight', 'black_rook'],
            ['black_pawn', 'black_pawn', 'black_pawn', 'black_pawn', 'black_pawn', 'black_pawn', 'black_pawn', 'black_pawn'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['white_pawn', 'white_pawn', 'white_pawn', 'white_pawn', 'white_pawn', 'white_pawn', 'white_pawn', 'white_pawn'],
            ['white_rook', 'white_knight', 'white_bishop', 'white_queen', 'white_king', 'white_bishop', 'white_knight', 'white_rook'],
        ];
        board = initialBoard.map(row => row.slice()); // Deep copy
        currentPlayer = 'white';
        selectedPiece = null;
        whiteKingPosition = [7, 4];
        blackKingPosition = [0, 4];
        gameEnded = false;
        statusElement.textContent = "White's Turn";
    }

    function renderBoard() {
        boardElement.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const square = document.createElement('div');
                square.classList.add('square');
                square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                square.dataset.row = r;
                square.dataset.col = c;

                const pieceName = board[r][c];
                if (pieceName) {
                    square.innerHTML = pieces[pieceName].img;
                }
                
                // Add event listeners
                square.addEventListener('click', () => onSquareClick(r, c));

                boardElement.appendChild(square);
            }
        }
    }

    // --- Event Handlers ---
    resetButton.addEventListener('click', () => {
        createBoard();
        renderBoard();
    });

    async function onSquareClick(row, col) {
        if (gameEnded) return;

        // Deselect if clicking the same piece
        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
            clearHighlights();
            selectedPiece = null;
            return;
        }

        const piece = board[row][col];
        if (piece && piece.startsWith(currentPlayer)) {
            // Select a piece
            clearHighlights();
            selectedPiece = { piece, row, col };
            highlightSquare(row, col, 'selected');
            const validMoves = getValidMoves(row, col);
            validMoves.forEach(move => highlightSquare(move.row, move.col, 'valid-move'));
        } else if (selectedPiece) {
            // Move a piece
            const validMoves = getValidMoves(selectedPiece.row, selectedPiece.col);
            const move = validMoves.find(m => m.row === row && m.col === col);
            if (move) {
                await makeMove(selectedPiece.row, selectedPiece.col, row, col);
                clearHighlights();
                selectedPiece = null;
                
                if (!gameEnded) {
                    switchPlayer();
                    setTimeout(computerMove, 500); // AI's turn
                }
            }
        }
    }

    // --- Game Logic ---
    async function makeMove(fromRow, fromCol, toRow, toCol) {
        const piece = board[fromRow][fromCol];
        board[toRow][toCol] = piece;
        board[fromRow][fromCol] = null;
        
        // Update king position
        if (piece.endsWith('_king')) {
            if (piece.startsWith('white')) {
                whiteKingPosition = [toRow, toCol];
            } else {
                blackKingPosition = [toRow, toCol];
            }
        }

        // Pawn Promotion
        if (piece.endsWith('_pawn') && (toRow === 0 || toRow === 7)) {
            const color = piece.split('_')[0];
            const newPiece = await handlePromotion(color);
            board[toRow][toCol] = newPiece;
        }

        renderBoard();
    }

    function switchPlayer() {
        currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
        statusElement.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
        checkGameStatus();
    }

    function checkGameStatus() {
        const kingPos = currentPlayer === 'white' ? whiteKingPosition : blackKingPosition;
        const inCheck = isKingInCheck(currentPlayer);
        
        // Remove previous check highlights before adding new ones
        document.querySelectorAll('.check').forEach(el => el.classList.remove('check'));
        if (inCheck) {
            highlightSquare(kingPos[0], kingPos[1], 'check');
            statusElement.textContent += ' - Check!';
        }

        const hasMoves = hasLegalMoves(currentPlayer);

        if (!hasMoves) {
            gameEnded = true;
            if (inCheck) {
                statusElement.textContent = `Checkmate! ${currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
            } else {
                statusElement.textContent = "Stalemate! It's a draw!";
            }
        }
    }
    
    function hasLegalMoves(color) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (piece && piece.startsWith(color)) {
                    if (getValidMoves(r, c).length > 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // --- Move Validation ---
    function getValidMoves(row, col) {
        const piece = board[row][col];
        if (!piece) return [];

        const color = piece.split('_')[0];
        const type = piece.split('_')[1];
        let moves = [];

        switch (type) {
            case 'pawn': moves = getPawnMoves(row, col, color); break;
            case 'rook': moves = getRookMoves(row, col, color); break;
            case 'knight': moves = getKnightMoves(row, col, color); break;
            case 'bishop': moves = getBishopMoves(row, col, color); break;
            case 'queen': moves = getQueenMoves(row, col, color); break;
            case 'king': moves = getKingMoves(row, col, color); break;
        }
        
        // Filter out moves that would put the king in check
        return moves.filter(move => {
            // Simulate the move
            const originalPiece = board[move.row][move.col];
            board[move.row][move.col] = board[row][col];
            board[row][col] = null;
            
            const kingInCheckAfterMove = isKingInCheck(color);
            
            // Revert the move
            board[row][col] = board[move.row][move.col];
            board[move.row][move.col] = originalPiece;

            return !kingInCheckAfterMove;
        });
    }

    function isKingInCheck(kingColor) {
        const kingPos = kingColor === 'white' ? whiteKingPosition : blackKingPosition;
        const opponentColor = kingColor === 'white' ? 'black' : 'white';

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (piece && piece.startsWith(opponentColor)) {
                    // Get raw moves, not filtered for check, as we are checking for attacks
                    const moves = getRawMoves(r, c); 
                    if (moves.some(m => m.row === kingPos[0] && m.col === kingPos[1])) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function getRawMoves(row, col) {
        const piece = board[row][col];
        if (!piece) return [];
        const color = piece.split('_')[0];
        const type = piece.split('_')[1];

        switch (type) {
            case 'pawn': return getPawnMoves(row, col, color, true); // true to get attack moves only for check detection
            case 'rook': return getRookMoves(row, col, color);
            case 'knight': return getKnightMoves(row, col, color);
            case 'bishop': return getBishopMoves(row, col, color);
            case 'queen': return getQueenMoves(row, col, color);
            case 'king': return getKingMoves(row, col, color);
        }
        return [];
    }

    // --- Piece Move Generation ---
    function getPawnMoves(row, col, color, attacksOnly = false) {
        const moves = [];
        const dir = color === 'white' ? -1 : 1;
        const startRow = color === 'white' ? 6 : 1;

        // Forward 1
        if (!attacksOnly && isInBounds(row + dir, col) && !board[row + dir][col]) {
            moves.push({ row: row + dir, col });
            // Forward 2 from start
            if (row === startRow && isInBounds(row + 2 * dir, col) && !board[row + 2 * dir][col]) {
                moves.push({ row: row + 2 * dir, col });
            }
        }
        // Captures
        [-1, 1].forEach(cDir => {
            const newRow = row + dir;
            const newCol = col + cDir;
            if (isInBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (attacksOnly || (target && !target.startsWith(color))) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        });
        return moves;
    }

    function getRookMoves(row, col, color) {
        return getSlidingMoves(row, col, color, [[-1, 0], [1, 0], [0, -1], [0, 1]]);
    }

    function getBishopMoves(row, col, color) {
        return getSlidingMoves(row, col, color, [[-1, -1], [-1, 1], [1, -1], [1, 1]]);
    }

    function getQueenMoves(row, col, color) {
        return getSlidingMoves(row, col, color, [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]);
    }

    function getSlidingMoves(row, col, color, directions) {
        const moves = [];
        directions.forEach(([dr, dc]) => {
            for (let i = 1; i < 8; i++) {
                const newRow = row + i * dr;
                const newCol = col + i * dc;
                if (!isInBounds(newRow, newCol)) break;
                const target = board[newRow][newCol];
                if (target) {
                    if (!target.startsWith(color)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                    break;
                }
                moves.push({ row: newRow, col: newCol });
            }
        });
        return moves;
    }

    function getKnightMoves(row, col, color) {
        const moves = [];
        const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
        knightMoves.forEach(([dr, dc]) => {
            const newRow = row + dr;
            const newCol = col + dc;
            if (isInBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target || !target.startsWith(color)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        });
        return moves;
    }

    function getKingMoves(row, col, color) {
        const moves = [];
        const kingMoves = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        kingMoves.forEach(([dr, dc]) => {
            const newRow = row + dr;
            const newCol = col + dc;
             if (isInBounds(newRow, newCol)) {
                const target = board[newRow][newCol];
                if (!target || !target.startsWith(color)) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        });
        return moves;
    }
    
    // --- UI Helpers ---
    function highlightSquare(row, col, className) {
        const square = boardElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
        if(square) square.classList.add(className);
    }
    
    function clearHighlights() {
        document.querySelectorAll('.selected, .valid-move, .check').forEach(el => {
            el.classList.remove('selected', 'valid-move', 'check');
        });
    }

    function isInBounds(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    // --- Pawn Promotion ---
    function handlePromotion(color) {
        return new Promise(resolve => {
            promotionModal.style.display = 'flex';
            promotionChoices.innerHTML = '';
            const promotionPieces = ['queen', 'rook', 'knight', 'bishop'];
            promotionPieces.forEach(pieceType => {
                const pieceName = `${color}_${pieceType}`;
                const choice = document.createElement('div');
                choice.classList.add('promotion-choice', 'cursor-pointer', 'w-20', 'h-20');
                choice.innerHTML = pieces[pieceName].img;
                choice.onclick = () => {
                    promotionModal.style.display = 'none';
                    resolve(pieceName);
                };
                promotionChoices.appendChild(choice);
            });
        });
    }
    
    // --- Computer AI ---
    function computerMove() {
        if (gameEnded || currentPlayer !== 'black') return;
        
        const bestMove = findBestMove();

        if (bestMove) {
            setTimeout(async () => {
                await makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                switchPlayer();
            }, 300);
        }
    }
    
    function findBestMove() {
        let bestScore = -Infinity;
        let bestMove = null;
        const allMoves = [];
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (piece && piece.startsWith('black')) {
                    const validMoves = getValidMoves(r, c);
                    validMoves.forEach(move => {
                        allMoves.push({ fromRow: r, fromCol: c, toRow: move.row, toCol: move.col, piece });
                    });
                }
            }
        }
        
        if (allMoves.length === 0) return null;
        
        allMoves.forEach(move => {
            const score = evaluateMove(move);
            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        });

        // Add some randomness for a "Decent" Duck
        const topMoves = allMoves.filter(m => evaluateMove(m) >= bestScore - 1);
        return topMoves[Math.floor(Math.random() * topMoves.length)];
    }
    
    function evaluateMove(move) {
        let score = 0;
        const targetPieceName = board[move.toRow][move.toCol];
        
        // Capture bonus
        if (targetPieceName) {
            score += pieces[targetPieceName].value;
        }

        // Simulate the move to check for future threats
        const originalPiece = board[move.toRow][move.toCol];
        board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
        board[move.fromRow][move.fromCol] = null;
        
        // Check bonus
        if (isKingInCheck('white')) {
            score += 2;
        }
        
        // Is the moved piece now under attack?
        if (isSquareAttacked(move.toRow, move.toCol, 'white')) {
            score -= pieces[move.piece].value / 2;
        }

        // Revert the move
        board[move.fromRow][move.fromCol] = board[move.toRow][move.toCol];
        board[move.toRow][move.toCol] = originalPiece;
        
        // Positional bonus (simple version)
        score += (3.5 - Math.abs(3.5 - move.toRow)) * 0.1;
        score += (3.5 - Math.abs(3.5 - move.toCol)) * 0.1;

        return score;
    }

    function isSquareAttacked(row, col, byColor) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (piece && piece.startsWith(byColor)) {
                    const moves = getRawMoves(r, c);
                    if (moves.some(m => m.row === row && m.col === col)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // --- Start the game ---
    window.onload = () => {
        createBoard();
        renderBoard();
    };

    </script>

</body>
</html>

